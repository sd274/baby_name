from ..models import (
    BabyName,
    UserNameReaction,
    Reaction
)
from .base import NameModel
import pandas as pd
import os
from sklearn.cluster import KMeans



class RandomRecommendationModel(NameModel):
    def get_name_recommendation(self):
        qs = (
            BabyName
            .objects
            .filter(sex=self.sex)
            .exclude(
                baby_name_reaction__in=self.user_reactions
            )
            .order_by('?')
        )
        return qs.first()




class SameFirstLetterModel(NameModel):

    def get_name_recommendation(self):
        user_reactions_df = (
            pd.DataFrame(list(
                self.user_reactions.all().values(
                    'name', 'name__name', 'reaction', 'reaction__reaction'
                )
            ))
            .query("reaction__reaction=='yes' or reaction__reaction=='maybe'")
        )
        user_reactions_df['first_letter'] = user_reactions_df.name__name.str[0]
        top_letter = (
            user_reactions_df
            .groupby('first_letter')
            .agg({'name': 'count'})
            .sort_values('name', ascending=False)
            .index
            .to_list()[0]

        )
        qs = (
            BabyName
            .objects
            .filter(
                sex=self.sex,
                name__startswith=top_letter
            )
            .exclude(
                baby_name_reaction__in=self.user_reactions
            )
            .order_by('?')
        )
        return qs.first()




class ClusterNames(NameModel):
    """
    Example of a model that needs to be prepared before running.
    Prepared data is stored as a csv and is prepared by running the prep_data method.

    Args:
        user (User): django user model
        sex (str): string of the sex that our user is interested in nameing.
    """

    def __init__(self, user, sex):
        super().__init__(user, sex)
        os.path.join(self.prep_folder, 'cluster_model.csv')
        try:
            print(os.path.join(self.prep_folder, 'cluster_model.csv'))
            self.cluster_data = pd.read_csv(
                os.path.join(self.prep_folder, 'cluster_model.csv')
            ).set_index('id')
        except:
            self.cluster_data = None
        

    def get_name_recommendation(self):
        """Gets the next name recommendation using the clusters generated by prep_model. This model looks at what cluster the yes and maybe names are assigned to and then returns a random name from the same cluster. In time we will look to make these cluster smarter.

        Returns:
            baby_name (BabyName): random baby name from the users favourate cluster.
        """
        if self.cluster_data is None:
            return None
        user_reactions_df = (
            pd.DataFrame(list(
                self.user_reactions.all().values(
                    'name', 'name__name', 'name__id', 'reaction', 'reaction__reaction'
                )
            ))
            .query("reaction__reaction=='yes' or reaction__reaction=='maybe'")
            .rename(columns={'name__id': 'id'})
            .set_index('id')
        )
        top_cluster = (
            user_reactions_df
            .join(self.cluster_data[['cluster']], how='inner')
            .groupby('cluster')
            .agg({'name': 'count'})
            .sort_values('name', ascending=False)
            .reset_index()
            .iloc[0]['cluster']
        )
        next_name = self.cluster_data.query('cluster == @top_cluster').sample(1)
        next_name_idx = next_name.index.array[0]
        baby_name = (
            BabyName
            .objects
            .get(pk=next_name_idx)
        )
        return baby_name

    def generate_clusters(self):
        """
        Assigns each baby name to a cluster. Currently this is 
        just based on the length of the name, in future we will 
        look to do more advanced clustering.

        Returns:
            df [DataFrame]: dataframe with a cluster label assigned to each cluster.
        """
        qs = (
            BabyName
            .objects
            .filter(sex=self.sex)
            .all()
            .values()
        )
        df = pd.DataFrame(list(qs)).set_index('id')
        df['name_length'] = df.name.str.len()
        df['first_letter'] = df.name.str[0]
        kmeans = KMeans(n_clusters=5).fit(df[['name_length']])
        df['cluster'] = kmeans.labels_
        return df

    def prep_model(self):
        """
        Generates and saves the clusters for the model to use. Makes use of the generate_cluster method. Returns True if the cluster is generated.
        Returns:
            success (bool): if the model correctly prepared
        """
        try:
            df = self.generate_clusters()
            df.to_csv(os.path.join(self.prep_folder, 'cluster_model.csv'))
            return True
        except:
            return False
